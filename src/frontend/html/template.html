<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STL Viewer with VTK.js</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"> <!-- Bootstrap CSS -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script> <!-- Chart.js library -->
    <style>
        .graph-container {
            width: 80%;
            max-width: 600px;
            margin: 30px auto;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            padding: 20px;
            background-color: white;
            border-radius: 8px;
        }
        body {
            margin: 0;
            padding: 0;
        }
        
        #controls {
            top: 5vh;
            left: 10px;
            background: transparent;
            padding: 10px;
            border-radius: 5px;
            margin-top: 15px;
        }

        .row {
            display: flex;
            justify-content: center;
            align-items: stretch;
            margin-top: 20px;
        }

        .col-half {
            flex: 1;
        }

        #vtkContainer {
            height: 30vh; /* Adjust height as needed */
            margin-right: 15px; /* Spacing between containers */
        }

        .graph-container {
            height: 50vh; /* Adjust height to match vtkContainer */
            display: flex;
            justify-content: center;
            align-items: center;
        }
    </style>
</head>
<body>

    
    <div class="container">
        <div class="row">
            <!-- vtkContainer Column -->
            <div class="col-half">
                <div id="vtkContainer"></div>
                <div id="controls">
                    <label for="input-roll">Roll:</label>
                    <input type="range" id="input-roll" min="-180" max="180" value="0" oninput="updateOrientation()">
                    <span id="roll-value">0</span>°<br>
                
                    <label for="input-pitch">Pitch:</label>
                    <input type="range" id="input-pitch" min="-180" max="180" value="0" oninput="updateOrientation()">
                    <span id="pitch-value">0</span>°<br>
                
                    <label for="input-yaw">Yaw:</label>
                    <input type="range" id="input-yaw" min="-180" max="180" value="0" oninput="updateOrientation()">
                    <span id="yaw-value">0</span>°<br>
                </div>
            </div>

            <!-- Chart Column -->
            <div class="col-half">
                <div class="graph-container">
                    <canvas id="myBarChart"></canvas>
                </div>
            </div>
        </div>
    </div>

    
    <script src="https://cdn.jsdelivr.net/npm/socket.io-client/dist/socket.io.js"></script>
    
    <script src="https://unpkg.com/vtk.js"></script>

    <script>
        const SERVER_PORT = 3000;
        const socket = io('http://localhost:' + SERVER_PORT);

        socket.on('arduinoData', (data) => {
            const ARRAY_DELIM  = '|';
            const DATA_DELIM  = ',';

            const ROLL_INDEX = 0;
            const PITCH_INDEX = 1;
            const YAW_INDEX = 2;

            const parsedData = data.split(DATA_DELIM);
            const MOTOR_SIGNAL_INDEX = 0;
            const ORIENTATION_INDEX = 1;
            
            let motors = parsedData[MOTOR_SIGNAL_INDEX].split(ARRAY_DELIM);
            let orientation = parsedData[ORIENTATION_INDEX].split(ARRAY_DELIM);

            motors = motors.map(motorSignal => formatMotorSignal(motorSignal));

            document.getElementById('input-roll').value = orientation[ROLL_INDEX];
            document.getElementById('input-pitch').value = orientation[PITCH_INDEX];
            document.getElementById('input-yaw').value = orientation[YAW_INDEX];

            updateOrientation();
            updateChartData(motors);
        });

        function formatMotorSignal(number) {
            return (number - 1000) / 1000;
        }


        // vtk.js modules we will use
        const vtkGenericRenderWindow = vtk.Rendering.Misc.vtkGenericRenderWindow;
        const vtkSTLReader = vtk.IO.Geometry.vtkSTLReader;
        const vtkActor = vtk.Rendering.Core.vtkActor;
        const vtkMapper = vtk.Rendering.Core.vtkMapper;
        const vtkVolumeMapper  = vtk.Rendering.Core.vtkVolumeMapper;
        const vtkVolume   = vtk.Rendering.Core.vtkVolume;

        // Create and initialize a generic render window
        const genericRenderWindow = vtkGenericRenderWindow.newInstance();
        genericRenderWindow.setContainer(document.getElementById('vtkContainer'));
        genericRenderWindow.resize();

        // Get the renderer, render window, and interactor from the generic render window
        const renderer = genericRenderWindow.getRenderer();
        const renderWindow = genericRenderWindow.getRenderWindow();
        const interactor = genericRenderWindow.getInteractor();

        interactor.setInteractorStyle(null);
                

        // Instantiate an STL reader, actor, and mapper
        const reader = vtkSTLReader.newInstance();
        const actor = vtkActor.newInstance();
        const mapper = vtkMapper.newInstance();
        const volumeMapper = vtkVolumeMapper.newInstance();
        const volume = vtkVolume.newInstance();

        volume.setMapper(volumeMapper);
        renderer.addVolume(volume);

        mapper.setScalarVisibility(false);
        actor.setMapper(mapper);;

    
        reader.setUrl('../python/stl/drone_model_centered.stl').then(() => {

            
            mapper.setInputConnection(reader.getOutputPort());
            const property = actor.getProperty();
            property.setColor(1, .5, 0.5);
            // property.setDiffuseColor(1, 0.5, 0.5);
            // property.setSpecular(0.1); // Shiny surface
            property.setSpecularPower(1); // Sharp specular effect
    
            // Adjust the ambient and diffuse lighting to control how "flat" the color appears
            property.setAmbient(0.05); // Lower ambient light
            property.setDiffuse(0.9); // Higher diffuse reflection
            renderer.addActor(actor);
    
            renderer.addActor(actor);
            renderer.resetCamera();
            renderWindow.render();
        });
    
        window.onresize = function () {
            interactor.handleResize();
        };

        

        let lastRoll = 0, lastPitch = 0, lastYaw = 0;
        actor.rotateX(-90);

        function updateOrientation() {
            let roll = parseFloat(document.getElementById('input-roll').value) || 0;
            let pitch = parseFloat(document.getElementById('input-pitch').value) || 0;
            let yaw = parseFloat(document.getElementById('input-yaw').value) || 0;

            document.getElementById('roll-value').innerText = roll;
            document.getElementById('pitch-value').innerText = pitch;
            document.getElementById('yaw-value').innerText = yaw;
            
            let deltaRoll = roll - lastRoll;
            let deltaPitch = pitch - lastPitch;
            let deltaYaw = yaw - lastYaw;
            
            actor.rotateX(deltaRoll);
            actor.rotateY(deltaPitch);
            actor.rotateZ(deltaYaw);

            lastRoll = roll;
            lastPitch = pitch;
            lastYaw = yaw;

            const camera = renderer.getActiveCamera();
            const bounds = actor.getBounds();
            const range = camera.getClippingRange();
            const distance = camera.getDistance();

            camera.setClippingRange(0.1 * (distance - (bounds[1] - bounds[0])), (2 * distance + (bounds[1] - bounds[0])));

            renderWindow.render();
        }

        // Flags to track the direction of the rotations
        let rollIncreasing = true;
        let pitchIncreasing = true;
        let yawIncreasing = true;

        // Function to generate a random speed within a range
        function getRandomSpeed(min, max) {
            return Math.random() * (max - min) + min;
        }

        function simulateDroneFlightBounded() {
            // Define your simulation parameters
            let rollSpeed = getRandomSpeed(0.1, 0.5);
            let pitchSpeed = getRandomSpeed(0.2, 0.3);
            let yawSpeed = getRandomSpeed(0.1, 0.4);


            // Define bounds for roll, pitch, and yaw
            const rollBounds = [-91, -85]; // degrees
            const pitchBounds = [-11, 12.5];
            const yawBounds = [-30, 32];

            // Update the orientation and reverse direction at bounds
            if (lastRoll >= rollBounds[1]) rollIncreasing = false;
            if (lastRoll <= rollBounds[0]) rollIncreasing = true;
            if (lastPitch >= pitchBounds[1]) pitchIncreasing = false;
            if (lastPitch <= pitchBounds[0]) pitchIncreasing = true;
            if (lastYaw >= yawBounds[1]) yawIncreasing = false;
            if (lastYaw <= yawBounds[0]) yawIncreasing = true;

            // Apply the changes based on the direction flags
            lastRoll += rollIncreasing ? rollSpeed : -rollSpeed;
            lastPitch += pitchIncreasing ? pitchSpeed : -pitchSpeed;
            lastYaw += yawIncreasing ? yawSpeed : -yawSpeed;

            // Apply the rotation to the drone actor
            actor.rotateX(rollIncreasing ? rollSpeed : -rollSpeed);
            actor.rotateY(pitchIncreasing ? pitchSpeed : -pitchSpeed);
            actor.rotateZ(yawIncreasing ? yawSpeed : -yawSpeed);

            document.getElementById('input-roll').value = lastRoll;
            document.getElementById('input-pitch').value = lastPitch;
            document.getElementById('input-yaw').value = lastYaw;

            document.getElementById('roll-value').innerText = lastRoll.toFixed(1);
            document.getElementById('pitch-value').innerText = lastPitch.toFixed(1);
            document.getElementById('yaw-value').innerText = lastYaw.toFixed(1);

            // Update the renderer and render window
            renderWindow.render();

            // Continue the animation loop
            requestAnimationFrame(simulateDroneFlightBounded);
        }

    function getColorForValue(value) {
        var red = value > 0.5 ? 255 : Math.round(510 * value);
        var green = value < 0.5 ? 255 : Math.round(510 * (1 - value));
        return 'rgb(' + red + ',' + green + ',0)';
    }

    var ctx = document.getElementById('myBarChart').getContext('2d');
    var myBarChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: ['Bar 1', 'Bar 2', 'Bar 3', 'Bar 4'], 
            datasets: [{
                label: 'Bar Values',
                data: [0, 0, 0, 0], 
                backgroundColor: ['green', 'green', 'green', 'green'], 
                borderColor: ['green', 'green', 'green', 'green'],
                borderWidth: 1
            }]
        },
        options: {
            scales: {
                y: {
                    beginAtZero: true,
                    max: 1 
                }
            },
            animation: {
                duration: 100 
            },
            plugins: {
                legend: {
                    display: false
                }
            },
            onHover: (event, chartElement) => {
                event.native.target.style.cursor = chartElement[0] ? 'pointer' : 'default';
            }
        }
    });

    function updateChartData(values) {
        myBarChart.data.datasets.forEach((dataset) => {
            dataset.data = values; 
            dataset.backgroundColor = values.map(value => getColorForValue(value)); 
            dataset.borderColor = dataset.backgroundColor;
        });
        myBarChart.update();
    }

        // Start the simulation
        // simulateDroneFlightBounded();
    </script>
</body>
</html>
